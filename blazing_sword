#!/bin/sh
#
# blazing_sword
#
# Automatically starts a Vault cluster for use in development or other
# evaluation style use cases:
#
# - Initialize Vault
# - Save key material to temporary file
# - Unseal Vault with key material from temporary file
# - Enable a range of auth and secret backends with default mounts
#
# ‼️ PLEASE DO NOT USE THIS IN PRODUCTION ‼️
#
# Pick one, fix one!
# shellcheck disable=SC1117,SC2154,SC2059,SC2039,SC1091

. ./skydome

# check cli capabilities
check_cli_cap() {
  vault_version="$(vault version | awk '{print $2}' | cut -d 'v' -f2)"
  vault_min_version="$(vault version | awk '{print $2}' | cut -d 'v' -f2 | cut -d '.' -f2)"
  if [ "$vault_version" == "0.9.1" ] || [ "$vault_min_version" -lt "9" ]; then
    vault_cli_cap="0"
  else
    vault_cli_cap="1"
  fi
}

# Check for the existence of a temporary key material file
check_vault_file() {
  for file in ./vault/vault_*.tmp; do
    if [ -e "$file" ]; then
        msg info "Existing Vault file detected; pass filename as first argument and it will be used for unsealing."
        exit 0
    fi
  done
}

# Emit a little usage note
usage() {
  msg alert "Usage: vault_kitchen_sink [vault_dat.tmp]"
  exit 1
}

# Authenticate with initial root token
auth_root() {
  msg info "Authenticating with Vault root token ..."
  get_initial_root_token "${vault_dat}"
  vault auth "${init_root_token}"  > /dev/null 2>&1
}

# Enable audit log
enable_audit_logging() {
  msg complete "Enabled file based audit log at ./vault/logs/audit.log!"
  auth_root
  vault audit-enable file file_path=/vault/logs/audit.log  > /dev/null 2>&1
}

# Enable authentication backends
enable_auth_backends() {
  msg info "Enabling Vault authentication backends ..."
  auth_root
  vault auth-enable approle > /dev/null 2>&1
  msg complete "Enabled AppRole authentication backend!"
  # TODO: This needs to be conditionally added based on installed Vault
  # version as aws auth does not exist in older Vault versions
  #
  # vault auth-enable aws > /dev/null 2>&1
  # msg complete "Enabled AWS authentication backend!"
  #
  vault auth-enable ldap > /dev/null 2>&1
  msg complete "Enabled LDAP authentication backend!"
  vault auth-enable userpass > /dev/null 2>&1
  msg complete "Enabled Username & Password authentication backend!"
}

# Get a subset of unseal keys
get_unseal_keys() {
  msg info "Get unseal keys ..."
  k1=$(grep 'Unseal Key 1' "${vault_dat}" | awk '{print $NF}')
  k2=$(grep 'Unseal Key 2' "${vault_dat}" | awk '{print $NF}')
  k3=$(grep 'Unseal Key 3' "${vault_dat}" | awk '{print $NF}')
}

# Get the initial root token
get_initial_root_token() {
  init_root_token=$(grep 'Initial Root Token' "${1}" | awk '{print $NF}')
}

# Initialize Vault and save temporary unseal keys and root token
initialize_vault() {
  check_cli_cap
  msg info "Initializing Vault ..."
  vault_dat="./vault/vault_DEV_ONLY-$(date +%s).tmp"
  if [ "$vault_cli_cap" -eq "1" ]; then
    v_init_cmd="vault operator init"
  else
    v_init_cmd="vault init"
  fi
  if ! $v_init_cmd | perl -pe 's/\x1b\[[0-9;]*m//g' > "${vault_dat}"; then
    errors=$((errors + $?))
    msg alert "Failed to initialize Vault!"
    exit $errors
  else
    msg complete "Vault initialized!"
  fi
}

# Mount database backend
mount_database_backend() {
  msg info "Mounting database backend ..."
  get_initial_root_token "${vault_dat}"
  vault mount database > /dev/null 2>&1
  msg complete "Mounted database backend!"
}

# Mount a handy mix of secret backends
mount_secret_backends() {
  msg info "Mounting Vault secret backends ..."
  get_initial_root_token "${vault_dat}"
  vault mount aws > /dev/null 2>&1
  msg complete "Mounted AWS secret backend!"
  vault mount consul > /dev/null 2>&1
  msg complete "Mounted Consul secret backend!"
  vault mount pki > /dev/null 2>&1
  msg complete "Mounted PKI secret backend!"
  vault mount postgresql > /dev/null 2>&1
  msg complete "Mounted Transit secret backend!"
  vault mount -path ssh-host-signer ssh > /dev/null 2>&1
  msg complete "Mounted SSH host signer backend!"
  vault mount -path ssh-client-signer ssh > /dev/null 2>&1
  msg complete "Mounted SSH client signer backend!"
}

# Get Vault status
status() {
  msg info "Vault status ..."
  printf "$(vault status)\n"
}

# Unseal Vault
unseal_vault() {
  msg info "Unsealing Vault ..."
  get_unseal_keys
  for i in {0..2}; do
    if ! VAULT_ADDR="http://localhost:820${i}" \
      vault unseal "$k1" > /dev/null 2>&1; then
      msg alert "Failed to unseal Vault 1"
      errors=$((errors + $?))
      exit $errors
    fi
    if ! VAULT_ADDR="http://localhost:820${i}" \
      vault unseal "$k2" > /dev/null 2>&1; then
      msg alert "Failed to unseal vault 2"
      errors=$((errors + $?))
      exit $errors
    fi
    if ! VAULT_ADDR="http://localhost:820${i}" \
      vault unseal "$k3" > /dev/null 2>&1; then
      msg alert "Failed to unseal Vault 3"
      errors=$((errors + $?))
      exit $errors
    fi
  done
  msg complete "Vault unsealed!"
}

# DO IT.
if [ $# -gt 1 ]
  then
    usage
fi

if (set -u; : "${1}") 2> /dev/null; then
  msg info "Filename argument specified; Use file: ${1}"
  vault_dat="${1}"
  k1=$(grep 'Unseal Key 1' "${vault_dat}" | awk '{print $NF}')
  k2=$(grep 'Unseal Key 2' "${vault_dat}" | awk '{print $NF}')
  k3=$(grep 'Unseal Key 3' "${vault_dat}" | awk '{print $NF}')
  msg info "Unsealing by default since filename used ..."
  for i in {0..2}; do
    VAULT_ADDR="http://localhost:820${i}" \
    vault unseal "${k1}" > /dev/null 2>&1 && \
    VAULT_ADDR="http://localhost:820${i}" \
    vault unseal "${k2}" > /dev/null 2>&1 && \
    VAULT_ADDR="http://localhost:820${i}" \
    vault unseal "${k3}" > /dev/null 2>&1;
  done
  auth_root
  status
  exit 0
else
  msg greeting "Form Blazing Sword! ..."
fi

unset VAULT_TOKEN
initialize_vault
unseal_vault
auth_root
enable_auth_backends
enable_audit_logging
mount_secret_backends
mount_database_backend
status